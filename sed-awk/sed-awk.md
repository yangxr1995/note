[[toc]]

# regex
## 工具
<https://regexr.com> 

## 基础
### 字符匹配
匹配一个位置的一个字符是什么
```bash
# 模式字符串中
# 第一个字符为 a
# 第二个字符为 b
sed -n '/ab/p' 1.tmp
```

如果需要匹配一个位置有多种字符的可能，则需要用`[]`
```bash
# 模式字符串中
# 第一个字符为 a 或 b
# 第二个字符为 b
sed -n '/[ab]b/p' 1.tmp
```
`[]`可以进行范围指定
```bash
# 模式字符串中
# 第一个字符为 a-b的字符或0-9或A-Z的字符
# 第二个字符为 b
sed -n '/[a-b0-9A-Z]b/p' 1.tmp
```
使用`[^]`可以进行取反
```bash
# 模式字符串中
# 第一个字符为 除了0-9的字符
# 第二个字符为 b
sed -n '/[^0-9]b/p' 1.tmp
```

正则提供了预定义字符类来匹配常见字符类
```bash
# 模式字符串中
# 第一个字符为 数字
# 第二个字符为 b
sed -n '/\db/p' 1.tmp
```
字符类
- `\d` : 数字
- `\D` : 非数字
- `\w` : 数字，字母，下划线
- `\W` : 非数字，字母，下划线
- `\s` : 空白字符，如空格，tab
- `\S` : 非空白字符
-  `.` : 任意字符


### 位置限定
- 行位置
  - `^` : 行开头
  - `$` : 行结尾 
- 单词位置
  - `\b` : 单词开头或结尾
  - `\B` : 非单词开头或结尾,即单词中间

### 量词
- `+` : 前面的字符或模式重复了一次或多次
- `*` : 前面的字符或模式重复了零次或多次
- `?` : 前面的字符或模式重复了零次或一次
- `{N}` : 前面的字符或模式重复了N次 
- `{N,M}` : 前面的字符或模式重复了N-M次 
- `{N,}` : 前面的字符或模式重复了至少N次

#### 贪婪匹配
贪婪匹配

寻找最多字符符号匹配
- at{3,}
  - **attt**
  - **atttt**
  - **attttt**

非贪婪匹配，寻找最少字符符合匹配
- at{3,}?
  - **attt**
  - **attt**t
  - **attt**tt

## 高级
### 分组和引用
使用小括号可以捕获分组
```bash
# 匹配 pattern 或 Pattern
sed -n '(P|p)attern' 1.tmp
```

```bash
# 匹配年月日,并捕获分组
# ([0-9]{4}) : 捕获年
# ([0-9]{2}) : 捕获月
# ([0-9]{2}) : 捕获日
sed -n '/\([0-9]\{4\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\)/p' ./1.tmp
```

```bash
# 将 年-月-日 替换为 月-日-年
# sed中引用分组使用 \n
# \1 : 第1个捕获的分组
# \2 : 第2个捕获的分组
# \3 : 第3个捕获的分组
sed  's/\([0-9]\{4\}\)-\([0-9]\{2\}\)-\([0-9]\{2\}\)/\2-\3-\1/g' ./1.tmp 
```

将如下内容的年月日都替换为月-日-年
```txt
2024-01-23
2024/02/23
2024:03:23
20240423
```
```bash
sed -i 's/\([0-9]\{4\}\)[\/:-]\?\([0-9]\{2\}\)[\/:-]\?\([0-9]\{2\}\)/\2-\3-\1/' ./1.tmp
```

```txt
01-23-2024
02-23-2024
03-23-2024
04-23-2024
```

匹配第一个字母和最后字母相同
```txt
alibaba
tencent
google
baidu
```

```bash
grep --color=always '\b\\([a-z]\)[a-z]*\1\b' 1.tmp
```

# sed

对文本进行增删改查
```bash
sed <option> [script] file1 file2....
```


```bash
# 1,2行添加
sed '1,2a addadd' file
# 3行删除
sed '3d' file
# 匹配行删除
sed '/asm/d' file
# 替换
sed -i '/asm/s/arm/x86' file
# 查找
sed -n '/aaa/p' file
```

常用action
- i: insert
- a: append
- d: delete
- s: substitution
- p: print

常用option
- -i: 将改变回写到文件
- -n: 不将改变内容打印到标志输出
- -e: 允许多个脚本命令被执行
- -f: 指定脚本文件  -f script-file
- -r: 使用扩展正则表达式
- -s: 如果sed多个文件，默认情况下，多个文件当成一个流处理，加-s，则分开处理，即确定行的操作会不同。

示例
修复头文件

```c
#define CUS_PARAMS_HARDVERSION "AAA 
CCC"
#define CUS_PARAMS_MODULENAME "AAA 
BBB"
```
步骤
1) 匹配错误的行， #define 开头，以模式"xxx结尾
2) 修改匹配行，将回车删除

```bash
# /^#define [A-Z_0-9]\+ "[a-zA-Z0-9._-]\+[^"]$/
# ^#define [A-Z_0-9]\+ 匹配前部分 
# "[a-zA-Z0-9._-]\+[^"]$ 匹配以 "xxx结尾
# {N; s/\n//g} 
#   N : 读取下一行并与当前行合并。
#   s/\n// : 替换回车
sed -i '/^#define [A-Z_0-9]\+ "[a-zA-Z0-9._-]\+[^"]$/{N; s/\n//g}' $@
```


